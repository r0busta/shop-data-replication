// Code generated by SQLBoiler 4.7.1 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/strmangle"
)

// ProductVariant is an object representing the database table.
type ProductVariant struct {
	ID                  int64             `boil:"id" json:"id" toml:"id" yaml:"id"`
	ProductID           int64             `boil:"product_id" json:"product_id" toml:"product_id" yaml:"product_id"`
	InventoryItemID     null.Int64        `boil:"inventory_item_id" json:"inventory_item_id,omitempty" toml:"inventory_item_id" yaml:"inventory_item_id,omitempty"`
	ImageID             null.Int64        `boil:"image_id" json:"image_id,omitempty" toml:"image_id" yaml:"image_id,omitempty"`
	Barcode             null.String       `boil:"barcode" json:"barcode,omitempty" toml:"barcode" yaml:"barcode,omitempty"`
	CompareAtPrice      types.NullDecimal `boil:"compare_at_price" json:"compare_at_price,omitempty" toml:"compare_at_price" yaml:"compare_at_price,omitempty"`
	FulfillmentService  null.String       `boil:"fulfillment_service" json:"fulfillment_service,omitempty" toml:"fulfillment_service" yaml:"fulfillment_service,omitempty"`
	Grams               null.Float64      `boil:"grams" json:"grams,omitempty" toml:"grams" yaml:"grams,omitempty"`
	InventoryManagement string            `boil:"inventory_management" json:"inventory_management" toml:"inventory_management" yaml:"inventory_management"`
	InventoryPolicy     string            `boil:"inventory_policy" json:"inventory_policy" toml:"inventory_policy" yaml:"inventory_policy"`
	InventoryQuantity   int               `boil:"inventory_quantity" json:"inventory_quantity" toml:"inventory_quantity" yaml:"inventory_quantity"`
	Position            int16             `boil:"position" json:"position" toml:"position" yaml:"position"`
	Price               types.Decimal     `boil:"price" json:"price" toml:"price" yaml:"price"`
	Sku                 null.String       `boil:"sku" json:"sku,omitempty" toml:"sku" yaml:"sku,omitempty"`
	Taxable             bool              `boil:"taxable" json:"taxable" toml:"taxable" yaml:"taxable"`
	Title               null.String       `boil:"title" json:"title,omitempty" toml:"title" yaml:"title,omitempty"`
	Weight              null.Float64      `boil:"weight" json:"weight,omitempty" toml:"weight" yaml:"weight,omitempty"`
	WeightUnit          string            `boil:"weight_unit" json:"weight_unit" toml:"weight_unit" yaml:"weight_unit"`
	CreatedAt           null.Time         `boil:"created_at" json:"created_at,omitempty" toml:"created_at" yaml:"created_at,omitempty"`
	UpdatedAt           null.Time         `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`
	Option1ValueID      null.Int64        `boil:"option_1_value_id" json:"option_1_value_id,omitempty" toml:"option_1_value_id" yaml:"option_1_value_id,omitempty"`
	Option2ValueID      null.Int64        `boil:"option_2_value_id" json:"option_2_value_id,omitempty" toml:"option_2_value_id" yaml:"option_2_value_id,omitempty"`
	Option3ValueID      null.Int64        `boil:"option_3_value_id" json:"option_3_value_id,omitempty" toml:"option_3_value_id" yaml:"option_3_value_id,omitempty"`

	R *productVariantR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L productVariantL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var ProductVariantColumns = struct {
	ID                  string
	ProductID           string
	InventoryItemID     string
	ImageID             string
	Barcode             string
	CompareAtPrice      string
	FulfillmentService  string
	Grams               string
	InventoryManagement string
	InventoryPolicy     string
	InventoryQuantity   string
	Position            string
	Price               string
	Sku                 string
	Taxable             string
	Title               string
	Weight              string
	WeightUnit          string
	CreatedAt           string
	UpdatedAt           string
	Option1ValueID      string
	Option2ValueID      string
	Option3ValueID      string
}{
	ID:                  "id",
	ProductID:           "product_id",
	InventoryItemID:     "inventory_item_id",
	ImageID:             "image_id",
	Barcode:             "barcode",
	CompareAtPrice:      "compare_at_price",
	FulfillmentService:  "fulfillment_service",
	Grams:               "grams",
	InventoryManagement: "inventory_management",
	InventoryPolicy:     "inventory_policy",
	InventoryQuantity:   "inventory_quantity",
	Position:            "position",
	Price:               "price",
	Sku:                 "sku",
	Taxable:             "taxable",
	Title:               "title",
	Weight:              "weight",
	WeightUnit:          "weight_unit",
	CreatedAt:           "created_at",
	UpdatedAt:           "updated_at",
	Option1ValueID:      "option_1_value_id",
	Option2ValueID:      "option_2_value_id",
	Option3ValueID:      "option_3_value_id",
}

var ProductVariantTableColumns = struct {
	ID                  string
	ProductID           string
	InventoryItemID     string
	ImageID             string
	Barcode             string
	CompareAtPrice      string
	FulfillmentService  string
	Grams               string
	InventoryManagement string
	InventoryPolicy     string
	InventoryQuantity   string
	Position            string
	Price               string
	Sku                 string
	Taxable             string
	Title               string
	Weight              string
	WeightUnit          string
	CreatedAt           string
	UpdatedAt           string
	Option1ValueID      string
	Option2ValueID      string
	Option3ValueID      string
}{
	ID:                  "product_variant.id",
	ProductID:           "product_variant.product_id",
	InventoryItemID:     "product_variant.inventory_item_id",
	ImageID:             "product_variant.image_id",
	Barcode:             "product_variant.barcode",
	CompareAtPrice:      "product_variant.compare_at_price",
	FulfillmentService:  "product_variant.fulfillment_service",
	Grams:               "product_variant.grams",
	InventoryManagement: "product_variant.inventory_management",
	InventoryPolicy:     "product_variant.inventory_policy",
	InventoryQuantity:   "product_variant.inventory_quantity",
	Position:            "product_variant.position",
	Price:               "product_variant.price",
	Sku:                 "product_variant.sku",
	Taxable:             "product_variant.taxable",
	Title:               "product_variant.title",
	Weight:              "product_variant.weight",
	WeightUnit:          "product_variant.weight_unit",
	CreatedAt:           "product_variant.created_at",
	UpdatedAt:           "product_variant.updated_at",
	Option1ValueID:      "product_variant.option_1_value_id",
	Option2ValueID:      "product_variant.option_2_value_id",
	Option3ValueID:      "product_variant.option_3_value_id",
}

// Generated where

type whereHelpernull_Float64 struct{ field string }

func (w whereHelpernull_Float64) EQ(x null.Float64) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}

func (w whereHelpernull_Float64) NEQ(x null.Float64) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}

func (w whereHelpernull_Float64) LT(x null.Float64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}

func (w whereHelpernull_Float64) LTE(x null.Float64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}

func (w whereHelpernull_Float64) GT(x null.Float64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}

func (w whereHelpernull_Float64) GTE(x null.Float64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_Float64) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Float64) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelperint16 struct{ field string }

func (w whereHelperint16) EQ(x int16) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint16) NEQ(x int16) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint16) LT(x int16) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint16) LTE(x int16) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint16) GT(x int16) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint16) GTE(x int16) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint16) IN(slice []int16) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}

func (w whereHelperint16) NIN(slice []int16) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

var ProductVariantWhere = struct {
	ID                  whereHelperint64
	ProductID           whereHelperint64
	InventoryItemID     whereHelpernull_Int64
	ImageID             whereHelpernull_Int64
	Barcode             whereHelpernull_String
	CompareAtPrice      whereHelpertypes_NullDecimal
	FulfillmentService  whereHelpernull_String
	Grams               whereHelpernull_Float64
	InventoryManagement whereHelperstring
	InventoryPolicy     whereHelperstring
	InventoryQuantity   whereHelperint
	Position            whereHelperint16
	Price               whereHelpertypes_Decimal
	Sku                 whereHelpernull_String
	Taxable             whereHelperbool
	Title               whereHelpernull_String
	Weight              whereHelpernull_Float64
	WeightUnit          whereHelperstring
	CreatedAt           whereHelpernull_Time
	UpdatedAt           whereHelpernull_Time
	Option1ValueID      whereHelpernull_Int64
	Option2ValueID      whereHelpernull_Int64
	Option3ValueID      whereHelpernull_Int64
}{
	ID:                  whereHelperint64{field: "`product_variant`.`id`"},
	ProductID:           whereHelperint64{field: "`product_variant`.`product_id`"},
	InventoryItemID:     whereHelpernull_Int64{field: "`product_variant`.`inventory_item_id`"},
	ImageID:             whereHelpernull_Int64{field: "`product_variant`.`image_id`"},
	Barcode:             whereHelpernull_String{field: "`product_variant`.`barcode`"},
	CompareAtPrice:      whereHelpertypes_NullDecimal{field: "`product_variant`.`compare_at_price`"},
	FulfillmentService:  whereHelpernull_String{field: "`product_variant`.`fulfillment_service`"},
	Grams:               whereHelpernull_Float64{field: "`product_variant`.`grams`"},
	InventoryManagement: whereHelperstring{field: "`product_variant`.`inventory_management`"},
	InventoryPolicy:     whereHelperstring{field: "`product_variant`.`inventory_policy`"},
	InventoryQuantity:   whereHelperint{field: "`product_variant`.`inventory_quantity`"},
	Position:            whereHelperint16{field: "`product_variant`.`position`"},
	Price:               whereHelpertypes_Decimal{field: "`product_variant`.`price`"},
	Sku:                 whereHelpernull_String{field: "`product_variant`.`sku`"},
	Taxable:             whereHelperbool{field: "`product_variant`.`taxable`"},
	Title:               whereHelpernull_String{field: "`product_variant`.`title`"},
	Weight:              whereHelpernull_Float64{field: "`product_variant`.`weight`"},
	WeightUnit:          whereHelperstring{field: "`product_variant`.`weight_unit`"},
	CreatedAt:           whereHelpernull_Time{field: "`product_variant`.`created_at`"},
	UpdatedAt:           whereHelpernull_Time{field: "`product_variant`.`updated_at`"},
	Option1ValueID:      whereHelpernull_Int64{field: "`product_variant`.`option_1_value_id`"},
	Option2ValueID:      whereHelpernull_Int64{field: "`product_variant`.`option_2_value_id`"},
	Option3ValueID:      whereHelpernull_Int64{field: "`product_variant`.`option_3_value_id`"},
}

// ProductVariantRels is where relationship names are stored.
var ProductVariantRels = struct {
	Product           string
	Option1Value      string
	Option2Value      string
	Option3Value      string
	Image             string
	InventoryItem     string
	VariantOrderLines string
}{
	Product:           "Product",
	Option1Value:      "Option1Value",
	Option2Value:      "Option2Value",
	Option3Value:      "Option3Value",
	Image:             "Image",
	InventoryItem:     "InventoryItem",
	VariantOrderLines: "VariantOrderLines",
}

// productVariantR is where relationships are stored.
type productVariantR struct {
	Product           *Product            `boil:"Product" json:"Product" toml:"Product" yaml:"Product"`
	Option1Value      *ProductOptionValue `boil:"Option1Value" json:"Option1Value" toml:"Option1Value" yaml:"Option1Value"`
	Option2Value      *ProductOptionValue `boil:"Option2Value" json:"Option2Value" toml:"Option2Value" yaml:"Option2Value"`
	Option3Value      *ProductOptionValue `boil:"Option3Value" json:"Option3Value" toml:"Option3Value" yaml:"Option3Value"`
	Image             *Image              `boil:"Image" json:"Image" toml:"Image" yaml:"Image"`
	InventoryItem     *Image              `boil:"InventoryItem" json:"InventoryItem" toml:"InventoryItem" yaml:"InventoryItem"`
	VariantOrderLines OrderLineSlice      `boil:"VariantOrderLines" json:"VariantOrderLines" toml:"VariantOrderLines" yaml:"VariantOrderLines"`
}

// NewStruct creates a new relationship struct
func (*productVariantR) NewStruct() *productVariantR {
	return &productVariantR{}
}

// productVariantL is where Load methods for each relationship are stored.
type productVariantL struct{}

var (
	productVariantAllColumns            = []string{"id", "product_id", "inventory_item_id", "image_id", "barcode", "compare_at_price", "fulfillment_service", "grams", "inventory_management", "inventory_policy", "inventory_quantity", "position", "price", "sku", "taxable", "title", "weight", "weight_unit", "created_at", "updated_at", "option_1_value_id", "option_2_value_id", "option_3_value_id"}
	productVariantColumnsWithoutDefault = []string{"id", "product_id", "inventory_item_id", "image_id", "barcode", "compare_at_price", "fulfillment_service", "grams", "inventory_management", "inventory_policy", "inventory_quantity", "position", "price", "sku", "taxable", "title", "weight", "weight_unit", "created_at", "updated_at", "option_1_value_id", "option_2_value_id", "option_3_value_id"}
	productVariantColumnsWithDefault    = []string{}
	productVariantPrimaryKeyColumns     = []string{"id"}
)

type (
	// ProductVariantSlice is an alias for a slice of pointers to ProductVariant.
	// This should almost always be used instead of []ProductVariant.
	ProductVariantSlice []*ProductVariant
	// ProductVariantHook is the signature for custom ProductVariant hook methods
	ProductVariantHook func(context.Context, boil.ContextExecutor, *ProductVariant) error

	productVariantQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	productVariantType                 = reflect.TypeOf(&ProductVariant{})
	productVariantMapping              = queries.MakeStructMapping(productVariantType)
	productVariantPrimaryKeyMapping, _ = queries.BindMapping(productVariantType, productVariantMapping, productVariantPrimaryKeyColumns)
	productVariantInsertCacheMut       sync.RWMutex
	productVariantInsertCache          = make(map[string]insertCache)
	productVariantUpdateCacheMut       sync.RWMutex
	productVariantUpdateCache          = make(map[string]updateCache)
	productVariantUpsertCacheMut       sync.RWMutex
	productVariantUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var (
	productVariantBeforeInsertHooks []ProductVariantHook
	productVariantBeforeUpdateHooks []ProductVariantHook
	productVariantBeforeDeleteHooks []ProductVariantHook
	productVariantBeforeUpsertHooks []ProductVariantHook
)

var (
	productVariantAfterInsertHooks []ProductVariantHook
	productVariantAfterSelectHooks []ProductVariantHook
	productVariantAfterUpdateHooks []ProductVariantHook
	productVariantAfterDeleteHooks []ProductVariantHook
	productVariantAfterUpsertHooks []ProductVariantHook
)

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *ProductVariant) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range productVariantBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *ProductVariant) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range productVariantBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *ProductVariant) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range productVariantBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *ProductVariant) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range productVariantBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *ProductVariant) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range productVariantAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *ProductVariant) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range productVariantAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *ProductVariant) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range productVariantAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *ProductVariant) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range productVariantAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *ProductVariant) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range productVariantAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddProductVariantHook registers your hook function for all future operations.
func AddProductVariantHook(hookPoint boil.HookPoint, productVariantHook ProductVariantHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		productVariantBeforeInsertHooks = append(productVariantBeforeInsertHooks, productVariantHook)
	case boil.BeforeUpdateHook:
		productVariantBeforeUpdateHooks = append(productVariantBeforeUpdateHooks, productVariantHook)
	case boil.BeforeDeleteHook:
		productVariantBeforeDeleteHooks = append(productVariantBeforeDeleteHooks, productVariantHook)
	case boil.BeforeUpsertHook:
		productVariantBeforeUpsertHooks = append(productVariantBeforeUpsertHooks, productVariantHook)
	case boil.AfterInsertHook:
		productVariantAfterInsertHooks = append(productVariantAfterInsertHooks, productVariantHook)
	case boil.AfterSelectHook:
		productVariantAfterSelectHooks = append(productVariantAfterSelectHooks, productVariantHook)
	case boil.AfterUpdateHook:
		productVariantAfterUpdateHooks = append(productVariantAfterUpdateHooks, productVariantHook)
	case boil.AfterDeleteHook:
		productVariantAfterDeleteHooks = append(productVariantAfterDeleteHooks, productVariantHook)
	case boil.AfterUpsertHook:
		productVariantAfterUpsertHooks = append(productVariantAfterUpsertHooks, productVariantHook)
	}
}

// One returns a single productVariant record from the query.
func (q productVariantQuery) One(ctx context.Context, exec boil.ContextExecutor) (*ProductVariant, error) {
	o := &ProductVariant{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for product_variant")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all ProductVariant records from the query.
func (q productVariantQuery) All(ctx context.Context, exec boil.ContextExecutor) (ProductVariantSlice, error) {
	var o []*ProductVariant

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to ProductVariant slice")
	}

	if len(productVariantAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all ProductVariant records in the query.
func (q productVariantQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count product_variant rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q productVariantQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if product_variant exists")
	}

	return count > 0, nil
}

// Product pointed to by the foreign key.
func (o *ProductVariant) Product(mods ...qm.QueryMod) productQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`id` = ?", o.ProductID),
	}

	queryMods = append(queryMods, mods...)

	query := Products(queryMods...)
	queries.SetFrom(query.Query, "`product`")

	return query
}

// Option1Value pointed to by the foreign key.
func (o *ProductVariant) Option1Value(mods ...qm.QueryMod) productOptionValueQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`option_id` = ?", o.Option1ValueID),
	}

	queryMods = append(queryMods, mods...)

	query := ProductOptionValues(queryMods...)
	queries.SetFrom(query.Query, "`product_option_value`")

	return query
}

// Option2Value pointed to by the foreign key.
func (o *ProductVariant) Option2Value(mods ...qm.QueryMod) productOptionValueQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`option_id` = ?", o.Option2ValueID),
	}

	queryMods = append(queryMods, mods...)

	query := ProductOptionValues(queryMods...)
	queries.SetFrom(query.Query, "`product_option_value`")

	return query
}

// Option3Value pointed to by the foreign key.
func (o *ProductVariant) Option3Value(mods ...qm.QueryMod) productOptionValueQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`option_id` = ?", o.Option3ValueID),
	}

	queryMods = append(queryMods, mods...)

	query := ProductOptionValues(queryMods...)
	queries.SetFrom(query.Query, "`product_option_value`")

	return query
}

// Image pointed to by the foreign key.
func (o *ProductVariant) Image(mods ...qm.QueryMod) imageQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`id` = ?", o.ImageID),
	}

	queryMods = append(queryMods, mods...)

	query := Images(queryMods...)
	queries.SetFrom(query.Query, "`image`")

	return query
}

// InventoryItem pointed to by the foreign key.
func (o *ProductVariant) InventoryItem(mods ...qm.QueryMod) imageQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`id` = ?", o.InventoryItemID),
	}

	queryMods = append(queryMods, mods...)

	query := Images(queryMods...)
	queries.SetFrom(query.Query, "`image`")

	return query
}

// VariantOrderLines retrieves all the order_line's OrderLines with an executor via variant_id column.
func (o *ProductVariant) VariantOrderLines(mods ...qm.QueryMod) orderLineQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`order_line`.`variant_id`=?", o.ID),
	)

	query := OrderLines(queryMods...)
	queries.SetFrom(query.Query, "`order_line`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`order_line`.*"})
	}

	return query
}

// LoadProduct allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (productVariantL) LoadProduct(ctx context.Context, e boil.ContextExecutor, singular bool, maybeProductVariant interface{}, mods queries.Applicator) error {
	var slice []*ProductVariant
	var object *ProductVariant

	if singular {
		object = maybeProductVariant.(*ProductVariant)
	} else {
		slice = *maybeProductVariant.(*[]*ProductVariant)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &productVariantR{}
		}
		args = append(args, object.ProductID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &productVariantR{}
			}

			for _, a := range args {
				if a == obj.ProductID {
					continue Outer
				}
			}

			args = append(args, obj.ProductID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`product`),
		qm.WhereIn(`product.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Product")
	}

	var resultSlice []*Product
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Product")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for product")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for product")
	}

	if len(productVariantAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Product = foreign
		if foreign.R == nil {
			foreign.R = &productR{}
		}
		foreign.R.ProductVariants = append(foreign.R.ProductVariants, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ProductID == foreign.ID {
				local.R.Product = foreign
				if foreign.R == nil {
					foreign.R = &productR{}
				}
				foreign.R.ProductVariants = append(foreign.R.ProductVariants, local)
				break
			}
		}
	}

	return nil
}

// LoadOption1Value allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (productVariantL) LoadOption1Value(ctx context.Context, e boil.ContextExecutor, singular bool, maybeProductVariant interface{}, mods queries.Applicator) error {
	var slice []*ProductVariant
	var object *ProductVariant

	if singular {
		object = maybeProductVariant.(*ProductVariant)
	} else {
		slice = *maybeProductVariant.(*[]*ProductVariant)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &productVariantR{}
		}
		if !queries.IsNil(object.Option1ValueID) {
			args = append(args, object.Option1ValueID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &productVariantR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Option1ValueID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.Option1ValueID) {
				args = append(args, obj.Option1ValueID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`product_option_value`),
		qm.WhereIn(`product_option_value.option_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load ProductOptionValue")
	}

	var resultSlice []*ProductOptionValue
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice ProductOptionValue")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for product_option_value")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for product_option_value")
	}

	if len(productVariantAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Option1Value = foreign
		if foreign.R == nil {
			foreign.R = &productOptionValueR{}
		}
		foreign.R.Option1ValueProductVariants = append(foreign.R.Option1ValueProductVariants, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.Option1ValueID, foreign.OptionID) {
				local.R.Option1Value = foreign
				if foreign.R == nil {
					foreign.R = &productOptionValueR{}
				}
				foreign.R.Option1ValueProductVariants = append(foreign.R.Option1ValueProductVariants, local)
				break
			}
		}
	}

	return nil
}

// LoadOption2Value allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (productVariantL) LoadOption2Value(ctx context.Context, e boil.ContextExecutor, singular bool, maybeProductVariant interface{}, mods queries.Applicator) error {
	var slice []*ProductVariant
	var object *ProductVariant

	if singular {
		object = maybeProductVariant.(*ProductVariant)
	} else {
		slice = *maybeProductVariant.(*[]*ProductVariant)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &productVariantR{}
		}
		if !queries.IsNil(object.Option2ValueID) {
			args = append(args, object.Option2ValueID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &productVariantR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Option2ValueID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.Option2ValueID) {
				args = append(args, obj.Option2ValueID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`product_option_value`),
		qm.WhereIn(`product_option_value.option_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load ProductOptionValue")
	}

	var resultSlice []*ProductOptionValue
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice ProductOptionValue")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for product_option_value")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for product_option_value")
	}

	if len(productVariantAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Option2Value = foreign
		if foreign.R == nil {
			foreign.R = &productOptionValueR{}
		}
		foreign.R.Option2ValueProductVariants = append(foreign.R.Option2ValueProductVariants, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.Option2ValueID, foreign.OptionID) {
				local.R.Option2Value = foreign
				if foreign.R == nil {
					foreign.R = &productOptionValueR{}
				}
				foreign.R.Option2ValueProductVariants = append(foreign.R.Option2ValueProductVariants, local)
				break
			}
		}
	}

	return nil
}

// LoadOption3Value allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (productVariantL) LoadOption3Value(ctx context.Context, e boil.ContextExecutor, singular bool, maybeProductVariant interface{}, mods queries.Applicator) error {
	var slice []*ProductVariant
	var object *ProductVariant

	if singular {
		object = maybeProductVariant.(*ProductVariant)
	} else {
		slice = *maybeProductVariant.(*[]*ProductVariant)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &productVariantR{}
		}
		if !queries.IsNil(object.Option3ValueID) {
			args = append(args, object.Option3ValueID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &productVariantR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Option3ValueID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.Option3ValueID) {
				args = append(args, obj.Option3ValueID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`product_option_value`),
		qm.WhereIn(`product_option_value.option_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load ProductOptionValue")
	}

	var resultSlice []*ProductOptionValue
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice ProductOptionValue")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for product_option_value")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for product_option_value")
	}

	if len(productVariantAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Option3Value = foreign
		if foreign.R == nil {
			foreign.R = &productOptionValueR{}
		}
		foreign.R.Option3ValueProductVariants = append(foreign.R.Option3ValueProductVariants, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.Option3ValueID, foreign.OptionID) {
				local.R.Option3Value = foreign
				if foreign.R == nil {
					foreign.R = &productOptionValueR{}
				}
				foreign.R.Option3ValueProductVariants = append(foreign.R.Option3ValueProductVariants, local)
				break
			}
		}
	}

	return nil
}

// LoadImage allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (productVariantL) LoadImage(ctx context.Context, e boil.ContextExecutor, singular bool, maybeProductVariant interface{}, mods queries.Applicator) error {
	var slice []*ProductVariant
	var object *ProductVariant

	if singular {
		object = maybeProductVariant.(*ProductVariant)
	} else {
		slice = *maybeProductVariant.(*[]*ProductVariant)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &productVariantR{}
		}
		if !queries.IsNil(object.ImageID) {
			args = append(args, object.ImageID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &productVariantR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ImageID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.ImageID) {
				args = append(args, obj.ImageID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`image`),
		qm.WhereIn(`image.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Image")
	}

	var resultSlice []*Image
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Image")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for image")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for image")
	}

	if len(productVariantAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Image = foreign
		if foreign.R == nil {
			foreign.R = &imageR{}
		}
		foreign.R.ProductVariants = append(foreign.R.ProductVariants, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ImageID, foreign.ID) {
				local.R.Image = foreign
				if foreign.R == nil {
					foreign.R = &imageR{}
				}
				foreign.R.ProductVariants = append(foreign.R.ProductVariants, local)
				break
			}
		}
	}

	return nil
}

// LoadInventoryItem allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (productVariantL) LoadInventoryItem(ctx context.Context, e boil.ContextExecutor, singular bool, maybeProductVariant interface{}, mods queries.Applicator) error {
	var slice []*ProductVariant
	var object *ProductVariant

	if singular {
		object = maybeProductVariant.(*ProductVariant)
	} else {
		slice = *maybeProductVariant.(*[]*ProductVariant)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &productVariantR{}
		}
		if !queries.IsNil(object.InventoryItemID) {
			args = append(args, object.InventoryItemID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &productVariantR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.InventoryItemID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.InventoryItemID) {
				args = append(args, obj.InventoryItemID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`image`),
		qm.WhereIn(`image.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Image")
	}

	var resultSlice []*Image
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Image")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for image")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for image")
	}

	if len(productVariantAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.InventoryItem = foreign
		if foreign.R == nil {
			foreign.R = &imageR{}
		}
		foreign.R.InventoryItemProductVariants = append(foreign.R.InventoryItemProductVariants, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.InventoryItemID, foreign.ID) {
				local.R.InventoryItem = foreign
				if foreign.R == nil {
					foreign.R = &imageR{}
				}
				foreign.R.InventoryItemProductVariants = append(foreign.R.InventoryItemProductVariants, local)
				break
			}
		}
	}

	return nil
}

// LoadVariantOrderLines allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (productVariantL) LoadVariantOrderLines(ctx context.Context, e boil.ContextExecutor, singular bool, maybeProductVariant interface{}, mods queries.Applicator) error {
	var slice []*ProductVariant
	var object *ProductVariant

	if singular {
		object = maybeProductVariant.(*ProductVariant)
	} else {
		slice = *maybeProductVariant.(*[]*ProductVariant)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &productVariantR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &productVariantR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`order_line`),
		qm.WhereIn(`order_line.variant_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load order_line")
	}

	var resultSlice []*OrderLine
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice order_line")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on order_line")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for order_line")
	}

	if len(orderLineAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.VariantOrderLines = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &orderLineR{}
			}
			foreign.R.Variant = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.VariantID) {
				local.R.VariantOrderLines = append(local.R.VariantOrderLines, foreign)
				if foreign.R == nil {
					foreign.R = &orderLineR{}
				}
				foreign.R.Variant = local
				break
			}
		}
	}

	return nil
}

// SetProduct of the productVariant to the related item.
// Sets o.R.Product to related.
// Adds o to related.R.ProductVariants.
func (o *ProductVariant) SetProduct(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Product) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `product_variant` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"product_id"}),
		strmangle.WhereClause("`", "`", 0, productVariantPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ProductID = related.ID
	if o.R == nil {
		o.R = &productVariantR{
			Product: related,
		}
	} else {
		o.R.Product = related
	}

	if related.R == nil {
		related.R = &productR{
			ProductVariants: ProductVariantSlice{o},
		}
	} else {
		related.R.ProductVariants = append(related.R.ProductVariants, o)
	}

	return nil
}

// SetOption1Value of the productVariant to the related item.
// Sets o.R.Option1Value to related.
// Adds o to related.R.Option1ValueProductVariants.
func (o *ProductVariant) SetOption1Value(ctx context.Context, exec boil.ContextExecutor, insert bool, related *ProductOptionValue) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `product_variant` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"option_1_value_id"}),
		strmangle.WhereClause("`", "`", 0, productVariantPrimaryKeyColumns),
	)
	values := []interface{}{related.OptionID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.Option1ValueID, related.OptionID)
	if o.R == nil {
		o.R = &productVariantR{
			Option1Value: related,
		}
	} else {
		o.R.Option1Value = related
	}

	if related.R == nil {
		related.R = &productOptionValueR{
			Option1ValueProductVariants: ProductVariantSlice{o},
		}
	} else {
		related.R.Option1ValueProductVariants = append(related.R.Option1ValueProductVariants, o)
	}

	return nil
}

// RemoveOption1Value relationship.
// Sets o.R.Option1Value to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *ProductVariant) RemoveOption1Value(ctx context.Context, exec boil.ContextExecutor, related *ProductOptionValue) error {
	var err error

	queries.SetScanner(&o.Option1ValueID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("option_1_value_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Option1Value = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Option1ValueProductVariants {
		if queries.Equal(o.Option1ValueID, ri.Option1ValueID) {
			continue
		}

		ln := len(related.R.Option1ValueProductVariants)
		if ln > 1 && i < ln-1 {
			related.R.Option1ValueProductVariants[i] = related.R.Option1ValueProductVariants[ln-1]
		}
		related.R.Option1ValueProductVariants = related.R.Option1ValueProductVariants[:ln-1]
		break
	}
	return nil
}

// SetOption2Value of the productVariant to the related item.
// Sets o.R.Option2Value to related.
// Adds o to related.R.Option2ValueProductVariants.
func (o *ProductVariant) SetOption2Value(ctx context.Context, exec boil.ContextExecutor, insert bool, related *ProductOptionValue) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `product_variant` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"option_2_value_id"}),
		strmangle.WhereClause("`", "`", 0, productVariantPrimaryKeyColumns),
	)
	values := []interface{}{related.OptionID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.Option2ValueID, related.OptionID)
	if o.R == nil {
		o.R = &productVariantR{
			Option2Value: related,
		}
	} else {
		o.R.Option2Value = related
	}

	if related.R == nil {
		related.R = &productOptionValueR{
			Option2ValueProductVariants: ProductVariantSlice{o},
		}
	} else {
		related.R.Option2ValueProductVariants = append(related.R.Option2ValueProductVariants, o)
	}

	return nil
}

// RemoveOption2Value relationship.
// Sets o.R.Option2Value to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *ProductVariant) RemoveOption2Value(ctx context.Context, exec boil.ContextExecutor, related *ProductOptionValue) error {
	var err error

	queries.SetScanner(&o.Option2ValueID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("option_2_value_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Option2Value = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Option2ValueProductVariants {
		if queries.Equal(o.Option2ValueID, ri.Option2ValueID) {
			continue
		}

		ln := len(related.R.Option2ValueProductVariants)
		if ln > 1 && i < ln-1 {
			related.R.Option2ValueProductVariants[i] = related.R.Option2ValueProductVariants[ln-1]
		}
		related.R.Option2ValueProductVariants = related.R.Option2ValueProductVariants[:ln-1]
		break
	}
	return nil
}

// SetOption3Value of the productVariant to the related item.
// Sets o.R.Option3Value to related.
// Adds o to related.R.Option3ValueProductVariants.
func (o *ProductVariant) SetOption3Value(ctx context.Context, exec boil.ContextExecutor, insert bool, related *ProductOptionValue) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `product_variant` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"option_3_value_id"}),
		strmangle.WhereClause("`", "`", 0, productVariantPrimaryKeyColumns),
	)
	values := []interface{}{related.OptionID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.Option3ValueID, related.OptionID)
	if o.R == nil {
		o.R = &productVariantR{
			Option3Value: related,
		}
	} else {
		o.R.Option3Value = related
	}

	if related.R == nil {
		related.R = &productOptionValueR{
			Option3ValueProductVariants: ProductVariantSlice{o},
		}
	} else {
		related.R.Option3ValueProductVariants = append(related.R.Option3ValueProductVariants, o)
	}

	return nil
}

// RemoveOption3Value relationship.
// Sets o.R.Option3Value to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *ProductVariant) RemoveOption3Value(ctx context.Context, exec boil.ContextExecutor, related *ProductOptionValue) error {
	var err error

	queries.SetScanner(&o.Option3ValueID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("option_3_value_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Option3Value = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Option3ValueProductVariants {
		if queries.Equal(o.Option3ValueID, ri.Option3ValueID) {
			continue
		}

		ln := len(related.R.Option3ValueProductVariants)
		if ln > 1 && i < ln-1 {
			related.R.Option3ValueProductVariants[i] = related.R.Option3ValueProductVariants[ln-1]
		}
		related.R.Option3ValueProductVariants = related.R.Option3ValueProductVariants[:ln-1]
		break
	}
	return nil
}

// SetImage of the productVariant to the related item.
// Sets o.R.Image to related.
// Adds o to related.R.ProductVariants.
func (o *ProductVariant) SetImage(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Image) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `product_variant` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"image_id"}),
		strmangle.WhereClause("`", "`", 0, productVariantPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ImageID, related.ID)
	if o.R == nil {
		o.R = &productVariantR{
			Image: related,
		}
	} else {
		o.R.Image = related
	}

	if related.R == nil {
		related.R = &imageR{
			ProductVariants: ProductVariantSlice{o},
		}
	} else {
		related.R.ProductVariants = append(related.R.ProductVariants, o)
	}

	return nil
}

// RemoveImage relationship.
// Sets o.R.Image to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *ProductVariant) RemoveImage(ctx context.Context, exec boil.ContextExecutor, related *Image) error {
	var err error

	queries.SetScanner(&o.ImageID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("image_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Image = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.ProductVariants {
		if queries.Equal(o.ImageID, ri.ImageID) {
			continue
		}

		ln := len(related.R.ProductVariants)
		if ln > 1 && i < ln-1 {
			related.R.ProductVariants[i] = related.R.ProductVariants[ln-1]
		}
		related.R.ProductVariants = related.R.ProductVariants[:ln-1]
		break
	}
	return nil
}

// SetInventoryItem of the productVariant to the related item.
// Sets o.R.InventoryItem to related.
// Adds o to related.R.InventoryItemProductVariants.
func (o *ProductVariant) SetInventoryItem(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Image) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `product_variant` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"inventory_item_id"}),
		strmangle.WhereClause("`", "`", 0, productVariantPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.InventoryItemID, related.ID)
	if o.R == nil {
		o.R = &productVariantR{
			InventoryItem: related,
		}
	} else {
		o.R.InventoryItem = related
	}

	if related.R == nil {
		related.R = &imageR{
			InventoryItemProductVariants: ProductVariantSlice{o},
		}
	} else {
		related.R.InventoryItemProductVariants = append(related.R.InventoryItemProductVariants, o)
	}

	return nil
}

// RemoveInventoryItem relationship.
// Sets o.R.InventoryItem to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *ProductVariant) RemoveInventoryItem(ctx context.Context, exec boil.ContextExecutor, related *Image) error {
	var err error

	queries.SetScanner(&o.InventoryItemID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("inventory_item_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.InventoryItem = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.InventoryItemProductVariants {
		if queries.Equal(o.InventoryItemID, ri.InventoryItemID) {
			continue
		}

		ln := len(related.R.InventoryItemProductVariants)
		if ln > 1 && i < ln-1 {
			related.R.InventoryItemProductVariants[i] = related.R.InventoryItemProductVariants[ln-1]
		}
		related.R.InventoryItemProductVariants = related.R.InventoryItemProductVariants[:ln-1]
		break
	}
	return nil
}

// AddVariantOrderLines adds the given related objects to the existing relationships
// of the product_variant, optionally inserting them as new records.
// Appends related to o.R.VariantOrderLines.
// Sets related.R.Variant appropriately.
func (o *ProductVariant) AddVariantOrderLines(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*OrderLine) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.VariantID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `order_line` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"variant_id"}),
				strmangle.WhereClause("`", "`", 0, orderLinePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.VariantID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &productVariantR{
			VariantOrderLines: related,
		}
	} else {
		o.R.VariantOrderLines = append(o.R.VariantOrderLines, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &orderLineR{
				Variant: o,
			}
		} else {
			rel.R.Variant = o
		}
	}
	return nil
}

// SetVariantOrderLines removes all previously related items of the
// product_variant replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Variant's VariantOrderLines accordingly.
// Replaces o.R.VariantOrderLines with related.
// Sets related.R.Variant's VariantOrderLines accordingly.
func (o *ProductVariant) SetVariantOrderLines(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*OrderLine) error {
	query := "update `order_line` set `variant_id` = null where `variant_id` = ?"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.VariantOrderLines {
			queries.SetScanner(&rel.VariantID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Variant = nil
		}

		o.R.VariantOrderLines = nil
	}
	return o.AddVariantOrderLines(ctx, exec, insert, related...)
}

// RemoveVariantOrderLines relationships from objects passed in.
// Removes related items from R.VariantOrderLines (uses pointer comparison, removal does not keep order)
// Sets related.R.Variant.
func (o *ProductVariant) RemoveVariantOrderLines(ctx context.Context, exec boil.ContextExecutor, related ...*OrderLine) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.VariantID, nil)
		if rel.R != nil {
			rel.R.Variant = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("variant_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.VariantOrderLines {
			if rel != ri {
				continue
			}

			ln := len(o.R.VariantOrderLines)
			if ln > 1 && i < ln-1 {
				o.R.VariantOrderLines[i] = o.R.VariantOrderLines[ln-1]
			}
			o.R.VariantOrderLines = o.R.VariantOrderLines[:ln-1]
			break
		}
	}

	return nil
}

// ProductVariants retrieves all the records using an executor.
func ProductVariants(mods ...qm.QueryMod) productVariantQuery {
	mods = append(mods, qm.From("`product_variant`"))
	return productVariantQuery{NewQuery(mods...)}
}

// FindProductVariant retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindProductVariant(ctx context.Context, exec boil.ContextExecutor, iD int64, selectCols ...string) (*ProductVariant, error) {
	productVariantObj := &ProductVariant{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `product_variant` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, productVariantObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from product_variant")
	}

	if err = productVariantObj.doAfterSelectHooks(ctx, exec); err != nil {
		return productVariantObj, err
	}

	return productVariantObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *ProductVariant) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no product_variant provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(productVariantColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	productVariantInsertCacheMut.RLock()
	cache, cached := productVariantInsertCache[key]
	productVariantInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			productVariantAllColumns,
			productVariantColumnsWithDefault,
			productVariantColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(productVariantType, productVariantMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(productVariantType, productVariantMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `product_variant` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `product_variant` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `product_variant` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, productVariantPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into product_variant")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for product_variant")
	}

CacheNoHooks:
	if !cached {
		productVariantInsertCacheMut.Lock()
		productVariantInsertCache[key] = cache
		productVariantInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the ProductVariant.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *ProductVariant) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	productVariantUpdateCacheMut.RLock()
	cache, cached := productVariantUpdateCache[key]
	productVariantUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			productVariantAllColumns,
			productVariantPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update product_variant, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `product_variant` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, productVariantPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(productVariantType, productVariantMapping, append(wl, productVariantPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update product_variant row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for product_variant")
	}

	if !cached {
		productVariantUpdateCacheMut.Lock()
		productVariantUpdateCache[key] = cache
		productVariantUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q productVariantQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for product_variant")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for product_variant")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o ProductVariantSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), productVariantPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `product_variant` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, productVariantPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in productVariant slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all productVariant")
	}
	return rowsAff, nil
}

var mySQLProductVariantUniqueColumns = []string{
	"id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *ProductVariant) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no product_variant provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(productVariantColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLProductVariantUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	productVariantUpsertCacheMut.RLock()
	cache, cached := productVariantUpsertCache[key]
	productVariantUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			productVariantAllColumns,
			productVariantColumnsWithDefault,
			productVariantColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			productVariantAllColumns,
			productVariantPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert product_variant, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`product_variant`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `product_variant` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(productVariantType, productVariantMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(productVariantType, productVariantMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for product_variant")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(productVariantType, productVariantMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for product_variant")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for product_variant")
	}

CacheNoHooks:
	if !cached {
		productVariantUpsertCacheMut.Lock()
		productVariantUpsertCache[key] = cache
		productVariantUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single ProductVariant record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *ProductVariant) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no ProductVariant provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), productVariantPrimaryKeyMapping)
	sql := "DELETE FROM `product_variant` WHERE `id`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from product_variant")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for product_variant")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q productVariantQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no productVariantQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from product_variant")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for product_variant")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o ProductVariantSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(productVariantBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), productVariantPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `product_variant` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, productVariantPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from productVariant slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for product_variant")
	}

	if len(productVariantAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *ProductVariant) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindProductVariant(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *ProductVariantSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := ProductVariantSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), productVariantPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `product_variant`.* FROM `product_variant` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, productVariantPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in ProductVariantSlice")
	}

	*o = slice

	return nil
}

// ProductVariantExists checks if the ProductVariant row exists.
func ProductVariantExists(ctx context.Context, exec boil.ContextExecutor, iD int64) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `product_variant` where `id`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if product_variant exists")
	}

	return exists, nil
}
