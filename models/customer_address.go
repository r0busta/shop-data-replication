// Code generated by SQLBoiler 4.7.1 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// CustomerAddress is an object representing the database table.
type CustomerAddress struct {
	ID           int64       `boil:"id" json:"id" toml:"id" yaml:"id"`
	CustomerID   int64       `boil:"customer_id" json:"customer_id" toml:"customer_id" yaml:"customer_id"`
	Address1     null.String `boil:"address1" json:"address1,omitempty" toml:"address1" yaml:"address1,omitempty"`
	Address2     null.String `boil:"address2" json:"address2,omitempty" toml:"address2" yaml:"address2,omitempty"`
	City         null.String `boil:"city" json:"city,omitempty" toml:"city" yaml:"city,omitempty"`
	Company      null.String `boil:"company" json:"company,omitempty" toml:"company" yaml:"company,omitempty"`
	Country      null.String `boil:"country" json:"country,omitempty" toml:"country" yaml:"country,omitempty"`
	CountryCode  null.String `boil:"country_code" json:"country_code,omitempty" toml:"country_code" yaml:"country_code,omitempty"`
	FirstName    null.String `boil:"first_name" json:"first_name,omitempty" toml:"first_name" yaml:"first_name,omitempty"`
	IsDefault    bool        `boil:"is_default" json:"is_default" toml:"is_default" yaml:"is_default"`
	LastName     null.String `boil:"last_name" json:"last_name,omitempty" toml:"last_name" yaml:"last_name,omitempty"`
	Name         null.String `boil:"name" json:"name,omitempty" toml:"name" yaml:"name,omitempty"`
	Phone        null.String `boil:"phone" json:"phone,omitempty" toml:"phone" yaml:"phone,omitempty"`
	Province     null.String `boil:"province" json:"province,omitempty" toml:"province" yaml:"province,omitempty"`
	ProvinceCode null.String `boil:"province_code" json:"province_code,omitempty" toml:"province_code" yaml:"province_code,omitempty"`
	Zip          null.String `boil:"zip" json:"zip,omitempty" toml:"zip" yaml:"zip,omitempty"`

	R *customerAddressR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L customerAddressL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var CustomerAddressColumns = struct {
	ID           string
	CustomerID   string
	Address1     string
	Address2     string
	City         string
	Company      string
	Country      string
	CountryCode  string
	FirstName    string
	IsDefault    string
	LastName     string
	Name         string
	Phone        string
	Province     string
	ProvinceCode string
	Zip          string
}{
	ID:           "id",
	CustomerID:   "customer_id",
	Address1:     "address1",
	Address2:     "address2",
	City:         "city",
	Company:      "company",
	Country:      "country",
	CountryCode:  "country_code",
	FirstName:    "first_name",
	IsDefault:    "is_default",
	LastName:     "last_name",
	Name:         "name",
	Phone:        "phone",
	Province:     "province",
	ProvinceCode: "province_code",
	Zip:          "zip",
}

var CustomerAddressTableColumns = struct {
	ID           string
	CustomerID   string
	Address1     string
	Address2     string
	City         string
	Company      string
	Country      string
	CountryCode  string
	FirstName    string
	IsDefault    string
	LastName     string
	Name         string
	Phone        string
	Province     string
	ProvinceCode string
	Zip          string
}{
	ID:           "customer_address.id",
	CustomerID:   "customer_address.customer_id",
	Address1:     "customer_address.address1",
	Address2:     "customer_address.address2",
	City:         "customer_address.city",
	Company:      "customer_address.company",
	Country:      "customer_address.country",
	CountryCode:  "customer_address.country_code",
	FirstName:    "customer_address.first_name",
	IsDefault:    "customer_address.is_default",
	LastName:     "customer_address.last_name",
	Name:         "customer_address.name",
	Phone:        "customer_address.phone",
	Province:     "customer_address.province",
	ProvinceCode: "customer_address.province_code",
	Zip:          "customer_address.zip",
}

// Generated where

var CustomerAddressWhere = struct {
	ID           whereHelperint64
	CustomerID   whereHelperint64
	Address1     whereHelpernull_String
	Address2     whereHelpernull_String
	City         whereHelpernull_String
	Company      whereHelpernull_String
	Country      whereHelpernull_String
	CountryCode  whereHelpernull_String
	FirstName    whereHelpernull_String
	IsDefault    whereHelperbool
	LastName     whereHelpernull_String
	Name         whereHelpernull_String
	Phone        whereHelpernull_String
	Province     whereHelpernull_String
	ProvinceCode whereHelpernull_String
	Zip          whereHelpernull_String
}{
	ID:           whereHelperint64{field: "`customer_address`.`id`"},
	CustomerID:   whereHelperint64{field: "`customer_address`.`customer_id`"},
	Address1:     whereHelpernull_String{field: "`customer_address`.`address1`"},
	Address2:     whereHelpernull_String{field: "`customer_address`.`address2`"},
	City:         whereHelpernull_String{field: "`customer_address`.`city`"},
	Company:      whereHelpernull_String{field: "`customer_address`.`company`"},
	Country:      whereHelpernull_String{field: "`customer_address`.`country`"},
	CountryCode:  whereHelpernull_String{field: "`customer_address`.`country_code`"},
	FirstName:    whereHelpernull_String{field: "`customer_address`.`first_name`"},
	IsDefault:    whereHelperbool{field: "`customer_address`.`is_default`"},
	LastName:     whereHelpernull_String{field: "`customer_address`.`last_name`"},
	Name:         whereHelpernull_String{field: "`customer_address`.`name`"},
	Phone:        whereHelpernull_String{field: "`customer_address`.`phone`"},
	Province:     whereHelpernull_String{field: "`customer_address`.`province`"},
	ProvinceCode: whereHelpernull_String{field: "`customer_address`.`province_code`"},
	Zip:          whereHelpernull_String{field: "`customer_address`.`zip`"},
}

// CustomerAddressRels is where relationship names are stored.
var CustomerAddressRels = struct {
	Customer                string
	DefaultAddressCustomers string
}{
	Customer:                "Customer",
	DefaultAddressCustomers: "DefaultAddressCustomers",
}

// customerAddressR is where relationships are stored.
type customerAddressR struct {
	Customer                *Customer     `boil:"Customer" json:"Customer" toml:"Customer" yaml:"Customer"`
	DefaultAddressCustomers CustomerSlice `boil:"DefaultAddressCustomers" json:"DefaultAddressCustomers" toml:"DefaultAddressCustomers" yaml:"DefaultAddressCustomers"`
}

// NewStruct creates a new relationship struct
func (*customerAddressR) NewStruct() *customerAddressR {
	return &customerAddressR{}
}

// customerAddressL is where Load methods for each relationship are stored.
type customerAddressL struct{}

var (
	customerAddressAllColumns            = []string{"id", "customer_id", "address1", "address2", "city", "company", "country", "country_code", "first_name", "is_default", "last_name", "name", "phone", "province", "province_code", "zip"}
	customerAddressColumnsWithoutDefault = []string{"id", "customer_id", "address1", "address2", "city", "company", "country", "country_code", "first_name", "is_default", "last_name", "name", "phone", "province", "province_code", "zip"}
	customerAddressColumnsWithDefault    = []string{}
	customerAddressPrimaryKeyColumns     = []string{"id"}
)

type (
	// CustomerAddressSlice is an alias for a slice of pointers to CustomerAddress.
	// This should almost always be used instead of []CustomerAddress.
	CustomerAddressSlice []*CustomerAddress
	// CustomerAddressHook is the signature for custom CustomerAddress hook methods
	CustomerAddressHook func(context.Context, boil.ContextExecutor, *CustomerAddress) error

	customerAddressQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	customerAddressType                 = reflect.TypeOf(&CustomerAddress{})
	customerAddressMapping              = queries.MakeStructMapping(customerAddressType)
	customerAddressPrimaryKeyMapping, _ = queries.BindMapping(customerAddressType, customerAddressMapping, customerAddressPrimaryKeyColumns)
	customerAddressInsertCacheMut       sync.RWMutex
	customerAddressInsertCache          = make(map[string]insertCache)
	customerAddressUpdateCacheMut       sync.RWMutex
	customerAddressUpdateCache          = make(map[string]updateCache)
	customerAddressUpsertCacheMut       sync.RWMutex
	customerAddressUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var customerAddressBeforeInsertHooks []CustomerAddressHook
var customerAddressBeforeUpdateHooks []CustomerAddressHook
var customerAddressBeforeDeleteHooks []CustomerAddressHook
var customerAddressBeforeUpsertHooks []CustomerAddressHook

var customerAddressAfterInsertHooks []CustomerAddressHook
var customerAddressAfterSelectHooks []CustomerAddressHook
var customerAddressAfterUpdateHooks []CustomerAddressHook
var customerAddressAfterDeleteHooks []CustomerAddressHook
var customerAddressAfterUpsertHooks []CustomerAddressHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *CustomerAddress) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerAddressBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *CustomerAddress) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerAddressBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *CustomerAddress) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerAddressBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *CustomerAddress) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerAddressBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *CustomerAddress) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerAddressAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *CustomerAddress) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerAddressAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *CustomerAddress) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerAddressAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *CustomerAddress) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerAddressAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *CustomerAddress) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerAddressAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddCustomerAddressHook registers your hook function for all future operations.
func AddCustomerAddressHook(hookPoint boil.HookPoint, customerAddressHook CustomerAddressHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		customerAddressBeforeInsertHooks = append(customerAddressBeforeInsertHooks, customerAddressHook)
	case boil.BeforeUpdateHook:
		customerAddressBeforeUpdateHooks = append(customerAddressBeforeUpdateHooks, customerAddressHook)
	case boil.BeforeDeleteHook:
		customerAddressBeforeDeleteHooks = append(customerAddressBeforeDeleteHooks, customerAddressHook)
	case boil.BeforeUpsertHook:
		customerAddressBeforeUpsertHooks = append(customerAddressBeforeUpsertHooks, customerAddressHook)
	case boil.AfterInsertHook:
		customerAddressAfterInsertHooks = append(customerAddressAfterInsertHooks, customerAddressHook)
	case boil.AfterSelectHook:
		customerAddressAfterSelectHooks = append(customerAddressAfterSelectHooks, customerAddressHook)
	case boil.AfterUpdateHook:
		customerAddressAfterUpdateHooks = append(customerAddressAfterUpdateHooks, customerAddressHook)
	case boil.AfterDeleteHook:
		customerAddressAfterDeleteHooks = append(customerAddressAfterDeleteHooks, customerAddressHook)
	case boil.AfterUpsertHook:
		customerAddressAfterUpsertHooks = append(customerAddressAfterUpsertHooks, customerAddressHook)
	}
}

// One returns a single customerAddress record from the query.
func (q customerAddressQuery) One(ctx context.Context, exec boil.ContextExecutor) (*CustomerAddress, error) {
	o := &CustomerAddress{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for customer_address")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all CustomerAddress records from the query.
func (q customerAddressQuery) All(ctx context.Context, exec boil.ContextExecutor) (CustomerAddressSlice, error) {
	var o []*CustomerAddress

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to CustomerAddress slice")
	}

	if len(customerAddressAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all CustomerAddress records in the query.
func (q customerAddressQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count customer_address rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q customerAddressQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if customer_address exists")
	}

	return count > 0, nil
}

// Customer pointed to by the foreign key.
func (o *CustomerAddress) Customer(mods ...qm.QueryMod) customerQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`id` = ?", o.CustomerID),
	}

	queryMods = append(queryMods, mods...)

	query := Customers(queryMods...)
	queries.SetFrom(query.Query, "`customer`")

	return query
}

// DefaultAddressCustomers retrieves all the customer's Customers with an executor via default_address_id column.
func (o *CustomerAddress) DefaultAddressCustomers(mods ...qm.QueryMod) customerQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`customer`.`default_address_id`=?", o.ID),
	)

	query := Customers(queryMods...)
	queries.SetFrom(query.Query, "`customer`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`customer`.*"})
	}

	return query
}

// LoadCustomer allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (customerAddressL) LoadCustomer(ctx context.Context, e boil.ContextExecutor, singular bool, maybeCustomerAddress interface{}, mods queries.Applicator) error {
	var slice []*CustomerAddress
	var object *CustomerAddress

	if singular {
		object = maybeCustomerAddress.(*CustomerAddress)
	} else {
		slice = *maybeCustomerAddress.(*[]*CustomerAddress)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &customerAddressR{}
		}
		args = append(args, object.CustomerID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &customerAddressR{}
			}

			for _, a := range args {
				if a == obj.CustomerID {
					continue Outer
				}
			}

			args = append(args, obj.CustomerID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`customer`),
		qm.WhereIn(`customer.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Customer")
	}

	var resultSlice []*Customer
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Customer")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for customer")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for customer")
	}

	if len(customerAddressAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Customer = foreign
		if foreign.R == nil {
			foreign.R = &customerR{}
		}
		foreign.R.CustomerAddresses = append(foreign.R.CustomerAddresses, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.CustomerID == foreign.ID {
				local.R.Customer = foreign
				if foreign.R == nil {
					foreign.R = &customerR{}
				}
				foreign.R.CustomerAddresses = append(foreign.R.CustomerAddresses, local)
				break
			}
		}
	}

	return nil
}

// LoadDefaultAddressCustomers allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (customerAddressL) LoadDefaultAddressCustomers(ctx context.Context, e boil.ContextExecutor, singular bool, maybeCustomerAddress interface{}, mods queries.Applicator) error {
	var slice []*CustomerAddress
	var object *CustomerAddress

	if singular {
		object = maybeCustomerAddress.(*CustomerAddress)
	} else {
		slice = *maybeCustomerAddress.(*[]*CustomerAddress)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &customerAddressR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &customerAddressR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`customer`),
		qm.WhereIn(`customer.default_address_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load customer")
	}

	var resultSlice []*Customer
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice customer")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on customer")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for customer")
	}

	if len(customerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.DefaultAddressCustomers = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &customerR{}
			}
			foreign.R.DefaultAddress = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.DefaultAddressID) {
				local.R.DefaultAddressCustomers = append(local.R.DefaultAddressCustomers, foreign)
				if foreign.R == nil {
					foreign.R = &customerR{}
				}
				foreign.R.DefaultAddress = local
				break
			}
		}
	}

	return nil
}

// SetCustomer of the customerAddress to the related item.
// Sets o.R.Customer to related.
// Adds o to related.R.CustomerAddresses.
func (o *CustomerAddress) SetCustomer(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Customer) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `customer_address` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"customer_id"}),
		strmangle.WhereClause("`", "`", 0, customerAddressPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.CustomerID = related.ID
	if o.R == nil {
		o.R = &customerAddressR{
			Customer: related,
		}
	} else {
		o.R.Customer = related
	}

	if related.R == nil {
		related.R = &customerR{
			CustomerAddresses: CustomerAddressSlice{o},
		}
	} else {
		related.R.CustomerAddresses = append(related.R.CustomerAddresses, o)
	}

	return nil
}

// AddDefaultAddressCustomers adds the given related objects to the existing relationships
// of the customer_address, optionally inserting them as new records.
// Appends related to o.R.DefaultAddressCustomers.
// Sets related.R.DefaultAddress appropriately.
func (o *CustomerAddress) AddDefaultAddressCustomers(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Customer) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.DefaultAddressID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `customer` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"default_address_id"}),
				strmangle.WhereClause("`", "`", 0, customerPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.DefaultAddressID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &customerAddressR{
			DefaultAddressCustomers: related,
		}
	} else {
		o.R.DefaultAddressCustomers = append(o.R.DefaultAddressCustomers, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &customerR{
				DefaultAddress: o,
			}
		} else {
			rel.R.DefaultAddress = o
		}
	}
	return nil
}

// SetDefaultAddressCustomers removes all previously related items of the
// customer_address replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.DefaultAddress's DefaultAddressCustomers accordingly.
// Replaces o.R.DefaultAddressCustomers with related.
// Sets related.R.DefaultAddress's DefaultAddressCustomers accordingly.
func (o *CustomerAddress) SetDefaultAddressCustomers(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Customer) error {
	query := "update `customer` set `default_address_id` = null where `default_address_id` = ?"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.DefaultAddressCustomers {
			queries.SetScanner(&rel.DefaultAddressID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.DefaultAddress = nil
		}

		o.R.DefaultAddressCustomers = nil
	}
	return o.AddDefaultAddressCustomers(ctx, exec, insert, related...)
}

// RemoveDefaultAddressCustomers relationships from objects passed in.
// Removes related items from R.DefaultAddressCustomers (uses pointer comparison, removal does not keep order)
// Sets related.R.DefaultAddress.
func (o *CustomerAddress) RemoveDefaultAddressCustomers(ctx context.Context, exec boil.ContextExecutor, related ...*Customer) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.DefaultAddressID, nil)
		if rel.R != nil {
			rel.R.DefaultAddress = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("default_address_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.DefaultAddressCustomers {
			if rel != ri {
				continue
			}

			ln := len(o.R.DefaultAddressCustomers)
			if ln > 1 && i < ln-1 {
				o.R.DefaultAddressCustomers[i] = o.R.DefaultAddressCustomers[ln-1]
			}
			o.R.DefaultAddressCustomers = o.R.DefaultAddressCustomers[:ln-1]
			break
		}
	}

	return nil
}

// CustomerAddresses retrieves all the records using an executor.
func CustomerAddresses(mods ...qm.QueryMod) customerAddressQuery {
	mods = append(mods, qm.From("`customer_address`"))
	return customerAddressQuery{NewQuery(mods...)}
}

// FindCustomerAddress retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindCustomerAddress(ctx context.Context, exec boil.ContextExecutor, iD int64, selectCols ...string) (*CustomerAddress, error) {
	customerAddressObj := &CustomerAddress{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `customer_address` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, customerAddressObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from customer_address")
	}

	if err = customerAddressObj.doAfterSelectHooks(ctx, exec); err != nil {
		return customerAddressObj, err
	}

	return customerAddressObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *CustomerAddress) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no customer_address provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(customerAddressColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	customerAddressInsertCacheMut.RLock()
	cache, cached := customerAddressInsertCache[key]
	customerAddressInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			customerAddressAllColumns,
			customerAddressColumnsWithDefault,
			customerAddressColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(customerAddressType, customerAddressMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(customerAddressType, customerAddressMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `customer_address` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `customer_address` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `customer_address` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, customerAddressPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into customer_address")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for customer_address")
	}

CacheNoHooks:
	if !cached {
		customerAddressInsertCacheMut.Lock()
		customerAddressInsertCache[key] = cache
		customerAddressInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the CustomerAddress.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *CustomerAddress) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	customerAddressUpdateCacheMut.RLock()
	cache, cached := customerAddressUpdateCache[key]
	customerAddressUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			customerAddressAllColumns,
			customerAddressPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update customer_address, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `customer_address` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, customerAddressPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(customerAddressType, customerAddressMapping, append(wl, customerAddressPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update customer_address row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for customer_address")
	}

	if !cached {
		customerAddressUpdateCacheMut.Lock()
		customerAddressUpdateCache[key] = cache
		customerAddressUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q customerAddressQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for customer_address")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for customer_address")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o CustomerAddressSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), customerAddressPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `customer_address` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, customerAddressPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in customerAddress slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all customerAddress")
	}
	return rowsAff, nil
}

var mySQLCustomerAddressUniqueColumns = []string{
	"id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *CustomerAddress) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no customer_address provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(customerAddressColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLCustomerAddressUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	customerAddressUpsertCacheMut.RLock()
	cache, cached := customerAddressUpsertCache[key]
	customerAddressUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			customerAddressAllColumns,
			customerAddressColumnsWithDefault,
			customerAddressColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			customerAddressAllColumns,
			customerAddressPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert customer_address, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`customer_address`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `customer_address` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(customerAddressType, customerAddressMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(customerAddressType, customerAddressMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for customer_address")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(customerAddressType, customerAddressMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for customer_address")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for customer_address")
	}

CacheNoHooks:
	if !cached {
		customerAddressUpsertCacheMut.Lock()
		customerAddressUpsertCache[key] = cache
		customerAddressUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single CustomerAddress record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *CustomerAddress) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no CustomerAddress provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), customerAddressPrimaryKeyMapping)
	sql := "DELETE FROM `customer_address` WHERE `id`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from customer_address")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for customer_address")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q customerAddressQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no customerAddressQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from customer_address")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for customer_address")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o CustomerAddressSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(customerAddressBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), customerAddressPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `customer_address` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, customerAddressPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from customerAddress slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for customer_address")
	}

	if len(customerAddressAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *CustomerAddress) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindCustomerAddress(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *CustomerAddressSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := CustomerAddressSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), customerAddressPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `customer_address`.* FROM `customer_address` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, customerAddressPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in CustomerAddressSlice")
	}

	*o = slice

	return nil
}

// CustomerAddressExists checks if the CustomerAddress row exists.
func CustomerAddressExists(ctx context.Context, exec boil.ContextExecutor, iD int64) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `customer_address` where `id`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if customer_address exists")
	}

	return exists, nil
}
