// Code generated by SQLBoiler 4.7.1 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/strmangle"
)

// Customer is an object representing the database table.
type Customer struct {
	ID                        int64         `boil:"id" json:"id" toml:"id" yaml:"id"`
	DefaultAddressID          null.Int64    `boil:"default_address_id" json:"default_address_id,omitempty" toml:"default_address_id" yaml:"default_address_id,omitempty"`
	AcceptsMarketing          bool          `boil:"accepts_marketing" json:"accepts_marketing" toml:"accepts_marketing" yaml:"accepts_marketing"`
	AcceptsMarketingUpdatedAt time.Time     `boil:"accepts_marketing_updated_at" json:"accepts_marketing_updated_at" toml:"accepts_marketing_updated_at" yaml:"accepts_marketing_updated_at"`
	CreatedAt                 time.Time     `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	Email                     null.String   `boil:"email" json:"email,omitempty" toml:"email" yaml:"email,omitempty"`
	FirstName                 string        `boil:"first_name" json:"first_name" toml:"first_name" yaml:"first_name"`
	LastName                  null.String   `boil:"last_name" json:"last_name,omitempty" toml:"last_name" yaml:"last_name,omitempty"`
	MarketingOptInLevel       string        `boil:"marketing_opt_in_level" json:"marketing_opt_in_level" toml:"marketing_opt_in_level" yaml:"marketing_opt_in_level"`
	Note                      null.String   `boil:"note" json:"note,omitempty" toml:"note" yaml:"note,omitempty"`
	OrderCount                int           `boil:"order_count" json:"order_count" toml:"order_count" yaml:"order_count"`
	Phone                     string        `boil:"phone" json:"phone" toml:"phone" yaml:"phone"`
	State                     string        `boil:"state" json:"state" toml:"state" yaml:"state"`
	TaxExempt                 bool          `boil:"tax_exempt" json:"tax_exempt" toml:"tax_exempt" yaml:"tax_exempt"`
	TotalSpent                types.Decimal `boil:"total_spent" json:"total_spent" toml:"total_spent" yaml:"total_spent"`
	UpdatedAt                 time.Time     `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	VerifiedEmail             bool          `boil:"verified_email" json:"verified_email" toml:"verified_email" yaml:"verified_email"`

	R *customerR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L customerL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var CustomerColumns = struct {
	ID                        string
	DefaultAddressID          string
	AcceptsMarketing          string
	AcceptsMarketingUpdatedAt string
	CreatedAt                 string
	Email                     string
	FirstName                 string
	LastName                  string
	MarketingOptInLevel       string
	Note                      string
	OrderCount                string
	Phone                     string
	State                     string
	TaxExempt                 string
	TotalSpent                string
	UpdatedAt                 string
	VerifiedEmail             string
}{
	ID:                        "id",
	DefaultAddressID:          "default_address_id",
	AcceptsMarketing:          "accepts_marketing",
	AcceptsMarketingUpdatedAt: "accepts_marketing_updated_at",
	CreatedAt:                 "created_at",
	Email:                     "email",
	FirstName:                 "first_name",
	LastName:                  "last_name",
	MarketingOptInLevel:       "marketing_opt_in_level",
	Note:                      "note",
	OrderCount:                "order_count",
	Phone:                     "phone",
	State:                     "state",
	TaxExempt:                 "tax_exempt",
	TotalSpent:                "total_spent",
	UpdatedAt:                 "updated_at",
	VerifiedEmail:             "verified_email",
}

var CustomerTableColumns = struct {
	ID                        string
	DefaultAddressID          string
	AcceptsMarketing          string
	AcceptsMarketingUpdatedAt string
	CreatedAt                 string
	Email                     string
	FirstName                 string
	LastName                  string
	MarketingOptInLevel       string
	Note                      string
	OrderCount                string
	Phone                     string
	State                     string
	TaxExempt                 string
	TotalSpent                string
	UpdatedAt                 string
	VerifiedEmail             string
}{
	ID:                        "customer.id",
	DefaultAddressID:          "customer.default_address_id",
	AcceptsMarketing:          "customer.accepts_marketing",
	AcceptsMarketingUpdatedAt: "customer.accepts_marketing_updated_at",
	CreatedAt:                 "customer.created_at",
	Email:                     "customer.email",
	FirstName:                 "customer.first_name",
	LastName:                  "customer.last_name",
	MarketingOptInLevel:       "customer.marketing_opt_in_level",
	Note:                      "customer.note",
	OrderCount:                "customer.order_count",
	Phone:                     "customer.phone",
	State:                     "customer.state",
	TaxExempt:                 "customer.tax_exempt",
	TotalSpent:                "customer.total_spent",
	UpdatedAt:                 "customer.updated_at",
	VerifiedEmail:             "customer.verified_email",
}

// Generated where

type whereHelperbool struct{ field string }

func (w whereHelperbool) EQ(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperbool) NEQ(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperbool) LT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperbool) LTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperbool) GT(x bool) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperbool) GTE(x bool) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }

type whereHelpertime_Time struct{ field string }

func (w whereHelpertime_Time) EQ(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.EQ, x)
}
func (w whereHelpertime_Time) NEQ(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelpertime_Time) LT(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertime_Time) LTE(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertime_Time) GT(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertime_Time) GTE(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelperint struct{ field string }

func (w whereHelperint) EQ(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint) NEQ(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint) LT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint) LTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint) GT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint) GTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint) IN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperint) NIN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelpertypes_Decimal struct{ field string }

func (w whereHelpertypes_Decimal) EQ(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.EQ, x)
}
func (w whereHelpertypes_Decimal) NEQ(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelpertypes_Decimal) LT(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_Decimal) LTE(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_Decimal) GT(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_Decimal) GTE(x types.Decimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

var CustomerWhere = struct {
	ID                        whereHelperint64
	DefaultAddressID          whereHelpernull_Int64
	AcceptsMarketing          whereHelperbool
	AcceptsMarketingUpdatedAt whereHelpertime_Time
	CreatedAt                 whereHelpertime_Time
	Email                     whereHelpernull_String
	FirstName                 whereHelperstring
	LastName                  whereHelpernull_String
	MarketingOptInLevel       whereHelperstring
	Note                      whereHelpernull_String
	OrderCount                whereHelperint
	Phone                     whereHelperstring
	State                     whereHelperstring
	TaxExempt                 whereHelperbool
	TotalSpent                whereHelpertypes_Decimal
	UpdatedAt                 whereHelpertime_Time
	VerifiedEmail             whereHelperbool
}{
	ID:                        whereHelperint64{field: "`customer`.`id`"},
	DefaultAddressID:          whereHelpernull_Int64{field: "`customer`.`default_address_id`"},
	AcceptsMarketing:          whereHelperbool{field: "`customer`.`accepts_marketing`"},
	AcceptsMarketingUpdatedAt: whereHelpertime_Time{field: "`customer`.`accepts_marketing_updated_at`"},
	CreatedAt:                 whereHelpertime_Time{field: "`customer`.`created_at`"},
	Email:                     whereHelpernull_String{field: "`customer`.`email`"},
	FirstName:                 whereHelperstring{field: "`customer`.`first_name`"},
	LastName:                  whereHelpernull_String{field: "`customer`.`last_name`"},
	MarketingOptInLevel:       whereHelperstring{field: "`customer`.`marketing_opt_in_level`"},
	Note:                      whereHelpernull_String{field: "`customer`.`note`"},
	OrderCount:                whereHelperint{field: "`customer`.`order_count`"},
	Phone:                     whereHelperstring{field: "`customer`.`phone`"},
	State:                     whereHelperstring{field: "`customer`.`state`"},
	TaxExempt:                 whereHelperbool{field: "`customer`.`tax_exempt`"},
	TotalSpent:                whereHelpertypes_Decimal{field: "`customer`.`total_spent`"},
	UpdatedAt:                 whereHelpertime_Time{field: "`customer`.`updated_at`"},
	VerifiedEmail:             whereHelperbool{field: "`customer`.`verified_email`"},
}

// CustomerRels is where relationship names are stored.
var CustomerRels = struct {
	DefaultAddress    string
	CustomerAddresses string
}{
	DefaultAddress:    "DefaultAddress",
	CustomerAddresses: "CustomerAddresses",
}

// customerR is where relationships are stored.
type customerR struct {
	DefaultAddress    *CustomerAddress     `boil:"DefaultAddress" json:"DefaultAddress" toml:"DefaultAddress" yaml:"DefaultAddress"`
	CustomerAddresses CustomerAddressSlice `boil:"CustomerAddresses" json:"CustomerAddresses" toml:"CustomerAddresses" yaml:"CustomerAddresses"`
}

// NewStruct creates a new relationship struct
func (*customerR) NewStruct() *customerR {
	return &customerR{}
}

// customerL is where Load methods for each relationship are stored.
type customerL struct{}

var (
	customerAllColumns            = []string{"id", "default_address_id", "accepts_marketing", "accepts_marketing_updated_at", "created_at", "email", "first_name", "last_name", "marketing_opt_in_level", "note", "order_count", "phone", "state", "tax_exempt", "total_spent", "updated_at", "verified_email"}
	customerColumnsWithoutDefault = []string{"id", "default_address_id", "accepts_marketing", "accepts_marketing_updated_at", "created_at", "email", "first_name", "last_name", "marketing_opt_in_level", "note", "order_count", "phone", "state", "tax_exempt", "total_spent", "updated_at", "verified_email"}
	customerColumnsWithDefault    = []string{}
	customerPrimaryKeyColumns     = []string{"id"}
)

type (
	// CustomerSlice is an alias for a slice of pointers to Customer.
	// This should almost always be used instead of []Customer.
	CustomerSlice []*Customer
	// CustomerHook is the signature for custom Customer hook methods
	CustomerHook func(context.Context, boil.ContextExecutor, *Customer) error

	customerQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	customerType                 = reflect.TypeOf(&Customer{})
	customerMapping              = queries.MakeStructMapping(customerType)
	customerPrimaryKeyMapping, _ = queries.BindMapping(customerType, customerMapping, customerPrimaryKeyColumns)
	customerInsertCacheMut       sync.RWMutex
	customerInsertCache          = make(map[string]insertCache)
	customerUpdateCacheMut       sync.RWMutex
	customerUpdateCache          = make(map[string]updateCache)
	customerUpsertCacheMut       sync.RWMutex
	customerUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var customerBeforeInsertHooks []CustomerHook
var customerBeforeUpdateHooks []CustomerHook
var customerBeforeDeleteHooks []CustomerHook
var customerBeforeUpsertHooks []CustomerHook

var customerAfterInsertHooks []CustomerHook
var customerAfterSelectHooks []CustomerHook
var customerAfterUpdateHooks []CustomerHook
var customerAfterDeleteHooks []CustomerHook
var customerAfterUpsertHooks []CustomerHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Customer) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Customer) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Customer) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Customer) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Customer) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Customer) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Customer) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Customer) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Customer) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range customerAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddCustomerHook registers your hook function for all future operations.
func AddCustomerHook(hookPoint boil.HookPoint, customerHook CustomerHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		customerBeforeInsertHooks = append(customerBeforeInsertHooks, customerHook)
	case boil.BeforeUpdateHook:
		customerBeforeUpdateHooks = append(customerBeforeUpdateHooks, customerHook)
	case boil.BeforeDeleteHook:
		customerBeforeDeleteHooks = append(customerBeforeDeleteHooks, customerHook)
	case boil.BeforeUpsertHook:
		customerBeforeUpsertHooks = append(customerBeforeUpsertHooks, customerHook)
	case boil.AfterInsertHook:
		customerAfterInsertHooks = append(customerAfterInsertHooks, customerHook)
	case boil.AfterSelectHook:
		customerAfterSelectHooks = append(customerAfterSelectHooks, customerHook)
	case boil.AfterUpdateHook:
		customerAfterUpdateHooks = append(customerAfterUpdateHooks, customerHook)
	case boil.AfterDeleteHook:
		customerAfterDeleteHooks = append(customerAfterDeleteHooks, customerHook)
	case boil.AfterUpsertHook:
		customerAfterUpsertHooks = append(customerAfterUpsertHooks, customerHook)
	}
}

// One returns a single customer record from the query.
func (q customerQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Customer, error) {
	o := &Customer{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for customer")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Customer records from the query.
func (q customerQuery) All(ctx context.Context, exec boil.ContextExecutor) (CustomerSlice, error) {
	var o []*Customer

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Customer slice")
	}

	if len(customerAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Customer records in the query.
func (q customerQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count customer rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q customerQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if customer exists")
	}

	return count > 0, nil
}

// DefaultAddress pointed to by the foreign key.
func (o *Customer) DefaultAddress(mods ...qm.QueryMod) customerAddressQuery {
	queryMods := []qm.QueryMod{
		qm.Where("`id` = ?", o.DefaultAddressID),
	}

	queryMods = append(queryMods, mods...)

	query := CustomerAddresses(queryMods...)
	queries.SetFrom(query.Query, "`customer_address`")

	return query
}

// CustomerAddresses retrieves all the customer_address's CustomerAddresses with an executor.
func (o *Customer) CustomerAddresses(mods ...qm.QueryMod) customerAddressQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`customer_address`.`customer_id`=?", o.ID),
	)

	query := CustomerAddresses(queryMods...)
	queries.SetFrom(query.Query, "`customer_address`")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"`customer_address`.*"})
	}

	return query
}

// LoadDefaultAddress allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (customerL) LoadDefaultAddress(ctx context.Context, e boil.ContextExecutor, singular bool, maybeCustomer interface{}, mods queries.Applicator) error {
	var slice []*Customer
	var object *Customer

	if singular {
		object = maybeCustomer.(*Customer)
	} else {
		slice = *maybeCustomer.(*[]*Customer)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &customerR{}
		}
		if !queries.IsNil(object.DefaultAddressID) {
			args = append(args, object.DefaultAddressID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &customerR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.DefaultAddressID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.DefaultAddressID) {
				args = append(args, obj.DefaultAddressID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`customer_address`),
		qm.WhereIn(`customer_address.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load CustomerAddress")
	}

	var resultSlice []*CustomerAddress
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice CustomerAddress")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for customer_address")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for customer_address")
	}

	if len(customerAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DefaultAddress = foreign
		if foreign.R == nil {
			foreign.R = &customerAddressR{}
		}
		foreign.R.DefaultAddressCustomers = append(foreign.R.DefaultAddressCustomers, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.DefaultAddressID, foreign.ID) {
				local.R.DefaultAddress = foreign
				if foreign.R == nil {
					foreign.R = &customerAddressR{}
				}
				foreign.R.DefaultAddressCustomers = append(foreign.R.DefaultAddressCustomers, local)
				break
			}
		}
	}

	return nil
}

// LoadCustomerAddresses allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (customerL) LoadCustomerAddresses(ctx context.Context, e boil.ContextExecutor, singular bool, maybeCustomer interface{}, mods queries.Applicator) error {
	var slice []*Customer
	var object *Customer

	if singular {
		object = maybeCustomer.(*Customer)
	} else {
		slice = *maybeCustomer.(*[]*Customer)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &customerR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &customerR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`customer_address`),
		qm.WhereIn(`customer_address.customer_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load customer_address")
	}

	var resultSlice []*CustomerAddress
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice customer_address")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on customer_address")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for customer_address")
	}

	if len(customerAddressAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.CustomerAddresses = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &customerAddressR{}
			}
			foreign.R.Customer = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.CustomerID {
				local.R.CustomerAddresses = append(local.R.CustomerAddresses, foreign)
				if foreign.R == nil {
					foreign.R = &customerAddressR{}
				}
				foreign.R.Customer = local
				break
			}
		}
	}

	return nil
}

// SetDefaultAddress of the customer to the related item.
// Sets o.R.DefaultAddress to related.
// Adds o to related.R.DefaultAddressCustomers.
func (o *Customer) SetDefaultAddress(ctx context.Context, exec boil.ContextExecutor, insert bool, related *CustomerAddress) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE `customer` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, []string{"default_address_id"}),
		strmangle.WhereClause("`", "`", 0, customerPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.DefaultAddressID, related.ID)
	if o.R == nil {
		o.R = &customerR{
			DefaultAddress: related,
		}
	} else {
		o.R.DefaultAddress = related
	}

	if related.R == nil {
		related.R = &customerAddressR{
			DefaultAddressCustomers: CustomerSlice{o},
		}
	} else {
		related.R.DefaultAddressCustomers = append(related.R.DefaultAddressCustomers, o)
	}

	return nil
}

// RemoveDefaultAddress relationship.
// Sets o.R.DefaultAddress to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *Customer) RemoveDefaultAddress(ctx context.Context, exec boil.ContextExecutor, related *CustomerAddress) error {
	var err error

	queries.SetScanner(&o.DefaultAddressID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("default_address_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.DefaultAddress = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.DefaultAddressCustomers {
		if queries.Equal(o.DefaultAddressID, ri.DefaultAddressID) {
			continue
		}

		ln := len(related.R.DefaultAddressCustomers)
		if ln > 1 && i < ln-1 {
			related.R.DefaultAddressCustomers[i] = related.R.DefaultAddressCustomers[ln-1]
		}
		related.R.DefaultAddressCustomers = related.R.DefaultAddressCustomers[:ln-1]
		break
	}
	return nil
}

// AddCustomerAddresses adds the given related objects to the existing relationships
// of the customer, optionally inserting them as new records.
// Appends related to o.R.CustomerAddresses.
// Sets related.R.Customer appropriately.
func (o *Customer) AddCustomerAddresses(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*CustomerAddress) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.CustomerID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `customer_address` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"customer_id"}),
				strmangle.WhereClause("`", "`", 0, customerAddressPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.CustomerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &customerR{
			CustomerAddresses: related,
		}
	} else {
		o.R.CustomerAddresses = append(o.R.CustomerAddresses, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &customerAddressR{
				Customer: o,
			}
		} else {
			rel.R.Customer = o
		}
	}
	return nil
}

// Customers retrieves all the records using an executor.
func Customers(mods ...qm.QueryMod) customerQuery {
	mods = append(mods, qm.From("`customer`"))
	return customerQuery{NewQuery(mods...)}
}

// FindCustomer retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindCustomer(ctx context.Context, exec boil.ContextExecutor, iD int64, selectCols ...string) (*Customer, error) {
	customerObj := &Customer{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `customer` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, customerObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from customer")
	}

	if err = customerObj.doAfterSelectHooks(ctx, exec); err != nil {
		return customerObj, err
	}

	return customerObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Customer) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no customer provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if o.UpdatedAt.IsZero() {
			o.UpdatedAt = currTime
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(customerColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	customerInsertCacheMut.RLock()
	cache, cached := customerInsertCache[key]
	customerInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			customerAllColumns,
			customerColumnsWithDefault,
			customerColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(customerType, customerMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(customerType, customerMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `customer` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `customer` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `customer` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, customerPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into customer")
	}

	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for customer")
	}

CacheNoHooks:
	if !cached {
		customerInsertCacheMut.Lock()
		customerInsertCache[key] = cache
		customerInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Customer.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Customer) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		o.UpdatedAt = currTime
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	customerUpdateCacheMut.RLock()
	cache, cached := customerUpdateCache[key]
	customerUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			customerAllColumns,
			customerPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update customer, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `customer` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, customerPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(customerType, customerMapping, append(wl, customerPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update customer row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for customer")
	}

	if !cached {
		customerUpdateCacheMut.Lock()
		customerUpdateCache[key] = cache
		customerUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q customerQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for customer")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for customer")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o CustomerSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), customerPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `customer` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, customerPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in customer slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all customer")
	}
	return rowsAff, nil
}

var mySQLCustomerUniqueColumns = []string{
	"id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Customer) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no customer provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		o.UpdatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(customerColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLCustomerUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	customerUpsertCacheMut.RLock()
	cache, cached := customerUpsertCache[key]
	customerUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			customerAllColumns,
			customerColumnsWithDefault,
			customerColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			customerAllColumns,
			customerPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert customer, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`customer`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `customer` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(customerType, customerMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(customerType, customerMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	_, err = exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for customer")
	}

	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(customerType, customerMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for customer")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for customer")
	}

CacheNoHooks:
	if !cached {
		customerUpsertCacheMut.Lock()
		customerUpsertCache[key] = cache
		customerUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Customer record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Customer) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Customer provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), customerPrimaryKeyMapping)
	sql := "DELETE FROM `customer` WHERE `id`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from customer")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for customer")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q customerQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no customerQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from customer")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for customer")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o CustomerSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(customerBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), customerPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `customer` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, customerPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from customer slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for customer")
	}

	if len(customerAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Customer) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindCustomer(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *CustomerSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := CustomerSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), customerPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `customer`.* FROM `customer` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, customerPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in CustomerSlice")
	}

	*o = slice

	return nil
}

// CustomerExists checks if the Customer row exists.
func CustomerExists(ctx context.Context, exec boil.ContextExecutor, iD int64) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `customer` where `id`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if customer exists")
	}

	return exists, nil
}
